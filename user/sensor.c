#include <user/sensor.h>
#include <utils.h>
#include <priority.h>
#include <user/vt100.h>
#include <user/syscall.h>
#include <debug.h> // assert
#include <user/train.h> // halting
#include <user/trackserver.h>

#define NUM_SENSORS     5
#define SENSOR_RESET    192
#define SENSOR_QUERY    (128 + NUM_SENSORS)
#define NUM_RECENT_SENSORS    7
#define POS                     "\033[4;24H"
#define POS1                    "\033[;24H"

// defines generated by ruby, for switch statement
// 5.times.each { |g|
//  16.times.each { |b|
//          puts "#define #{(g+'A'.ord).chr}#{b+1}\t((#{g} << 4) | #{b+1})"
// } }
#define A1  ((0 << 8) | 1)
#define A2  ((0 << 8) | 2)
#define A3  ((0 << 8) | 3)
#define A4  ((0 << 8) | 4)
#define A5  ((0 << 8) | 5)
#define A6  ((0 << 8) | 6)
#define A7  ((0 << 8) | 7)
#define A8  ((0 << 8) | 8)
#define A9  ((0 << 8) | 9)
#define A10 ((0 << 8) | 10)
#define A11 ((0 << 8) | 11)
#define A12 ((0 << 8) | 12)
#define A13 ((0 << 8) | 13)
#define A14 ((0 << 8) | 14)
#define A15 ((0 << 8) | 15)
#define A16 ((0 << 8) | 16)
#define B1  ((1 << 8) | 1)
#define B2  ((1 << 8) | 2)
#define B3  ((1 << 8) | 3)
#define B4  ((1 << 8) | 4)
#define B5  ((1 << 8) | 5)
#define B6  ((1 << 8) | 6)
#define B7  ((1 << 8) | 7)
#define B8  ((1 << 8) | 8)
#define B9  ((1 << 8) | 9)
#define B10 ((1 << 8) | 10)
#define B11 ((1 << 8) | 11)
#define B12 ((1 << 8) | 12)
#define B13 ((1 << 8) | 13)
#define B14 ((1 << 8) | 14)
#define B15 ((1 << 8) | 15)
#define B16 ((1 << 8) | 16)
#define C1  ((2 << 8) | 1)
#define C2  ((2 << 8) | 2)
#define C3  ((2 << 8) | 3)
#define C4  ((2 << 8) | 4)
#define C5  ((2 << 8) | 5)
#define C6  ((2 << 8) | 6)
#define C7  ((2 << 8) | 7)
#define C8  ((2 << 8) | 8)
#define C9  ((2 << 8) | 9)
#define C10 ((2 << 8) | 10)
#define C11 ((2 << 8) | 11)
#define C12 ((2 << 8) | 12)
#define C13 ((2 << 8) | 13)
#define C14 ((2 << 8) | 14)
#define C15 ((2 << 8) | 15)
#define C16 ((2 << 8) | 16)
#define D1  ((3 << 8) | 1)
#define D2  ((3 << 8) | 2)
#define D3  ((3 << 8) | 3)
#define D4  ((3 << 8) | 4)
#define D5  ((3 << 8) | 5)
#define D6  ((3 << 8) | 6)
#define D7  ((3 << 8) | 7)
#define D8  ((3 << 8) | 8)
#define D9  ((3 << 8) | 9)
#define D10 ((3 << 8) | 10)
#define D11 ((3 << 8) | 11)
#define D12 ((3 << 8) | 12)
#define D13 ((3 << 8) | 13)
#define D14 ((3 << 8) | 14)
#define D15 ((3 << 8) | 15)
#define D16 ((3 << 8) | 16)
#define E1  ((4 << 8) | 1)
#define E2  ((4 << 8) | 2)
#define E3  ((4 << 8) | 3)
#define E4  ((4 << 8) | 4)
#define E5  ((4 << 8) | 5)
#define E6  ((4 << 8) | 6)
#define E7  ((4 << 8) | 7)
#define E8  ((4 << 8) | 8)
#define E9  ((4 << 8) | 9)
#define E10 ((4 << 8) | 10)
#define E11 ((4 << 8) | 11)
#define E12 ((4 << 8) | 12)
#define E13 ((4 << 8) | 13)
#define E14 ((4 << 8) | 14)
#define E15 ((4 << 8) | 15)
#define E16 ((4 << 8) | 16)

static char *trackA =
"\033[2;44H"    "-- Track A --"
"\033[4;24H"    "---------12--11----------------------------------\\"
"\033[5;24H"    "-------4/   /  ---------13--------10-----------\\  \\"
"\033[6;24H"    "          14--/           \\   |  /              \\  \\"
"\033[7;24H"    "          /                \\  |/155              \\--9"
"\033[8;24H"    "         |                156\\|                    |"
"\033[9;24H"    "         |                    |\\154                |"
"\033[10;24H"   "          \\               153/|  \\               /--8"
"\033[11;24H"   "          15--\\            /  |   \\             /  /"
"\033[12;24H"   "--------\\   \\  ----------S---------S-----------/  /"
"\033[13;24H"   "---------1\\  \\---------6------------7------------/"
"\033[14;24H"   "-----------2\\           \\          /"
"\033[15;24H"   "-------------3-----------18--------5------------";

static char *trackB =
"\033[2;44H"    "-- Track B --"
"\033[4;24H"    "---------12--11----------------------------------\\"
"\033[5;24H"    "-------4/   /  ---------13--------10-----------\\  \\"
"\033[6;24H"    "      /   14--/           \\   |  /              \\  \\"
"\033[7;24H"    "   /-/    /                \\  |/155               \\--9"
"\033[8;24H"    "   |     |                156\\|                     |"
"\033[9;24H"    "   |     |                    |\\154                 |"
"\033[10;24H"   "   \\-     \\               153/| \\                /--8"
"\033[11;24H"   "     \\-\\  15--\\            /  |  \\              /  /"
"\033[12;24H"   "        \\   \\  ---------16--------17-----------/  /"
"\033[13;24H"   "---------1\\  \\---------6------------7------------/"
"\033[14;24H"   "-----------2\\           \\          /"
"\033[15;24H"   "-------------3-----------18--------5------------";

static SensorData recent_sensors[NUM_RECENT_SENSORS];

static char sensor_states[2 * NUM_SENSORS];
static int last_byte = 0;
static int recently_read = 0;

static int halt_train_number;
static SensorData halt_reading;

static void initDrawSensorArea() {
    String s;
    sinit(&s);
    sprintf(&s, VT_CURSOR_SAVE);
    vt_pos(&s, VT_SENSOR_ROW, VT_SENSOR_COL);
    sputstr(&s, VT_RESET);
    sputstr(&s, "-- RECENT SENSORS --\r\n");
    sputstr(&s, VT_RESET);
    sputstr(&s, VT_CURSOR_RESTORE);
    PutString(COM2, &s);
}

static void setSensorData(SensorData *s, char group, char offset) {
    // compiler hax to silence comparison of char is always true in limited range
    int newgroup = group * 1000;
    assert(0 <= newgroup && newgroup <= 4 * 1000);
    assert(1 <= (unsigned) offset && (unsigned) offset <= 16);
    s->group = group;
    s->offset = offset;
}

// static void trackDrawingFormat(String *s, const SensorData *reading, Track track) {
    // if(reading->offset == 0) {
    //     return;
    // }

    // unsigned sensor = (reading->group << 8) & reading->offset;
    // // switch statements generated by ruby:
    // // 5.times.each { |g| 16.times.each { |b| puts "case #{(g+'A'.ord).chr}#{b+1}: {break;}" } }
    // int row, col;
    // char dir;

    // // ------- Track A ----- //
    // if(track == A) {
    // }

    // // ------- Track B ----- //
    // else if(track == B) {
    //     switch(sensor) {
    //         case A1:    {row = 1;    col = 6;     dir = '>';  break;}
    //         case A2:    {row = 1;    col = 6;     dir = '<';  break;}
    //         case A3:    {row = ;    col = ;     dir = ' ';  break;}
    //         case A4:    {row = ;    col = ;     dir = ' ';  break;}
    //         case A5:    {row = ;    col = ;     dir = ' ';  break;}
    //         case A6:    {row = ;    col = ;     dir = ' ';  break;}
    //         case A7:    {row = ;    col = ;     dir = ' ';  break;}
    //         case A8:    {row = ;    col = ;     dir = ' ';  break;}
    //         case A9:    {row = ;    col = ;     dir = ' ';  break;}
    //         case A10:   {row = ;    col = ;     dir = ' ';  break;}
    //         case A11:   {row = ;    col = ;     dir = ' ';  break;}
    //         case A12:   {row = ;    col = ;     dir = ' ';  break;}
    //         case A13:   {row = ;    col = ;     dir = ' ';  break;}
    //         case A14:   {row = ;    col = ;     dir = ' ';  break;}
    //         case A15:   {row = ;    col = ;     dir = ' ';  break;}
    //         case A16:   {row = ;    col = ;     dir = ' ';  break;}

    //         case B1:    {row = ;    col = ;     dir = ' ';  break;}
    //         case B2:    {row = ;    col = ;     dir = ' ';  break;}
    //         case B3:    {row = ;    col = ;     dir = ' ';  break;}
    //         case B4:    {row = ;    col = ;     dir = ' ';  break;}
    //         case B5:    {row = ;    col = ;     dir = ' ';  break;}
    //         case B6:    {row = ;    col = ;     dir = ' ';  break;}
    //         case B7:    {row = ;    col = ;     dir = ' ';  break;}
    //         case B8:    {row = ;    col = ;     dir = ' ';  break;}
    //         case B9:    {row = ;    col = ;     dir = ' ';  break;}
    //         case B10:   {row = ;    col = ;     dir = ' ';  break;}
    //         case B11:   {row = ;    col = ;     dir = ' ';  break;}
    //         case B12:   {row = ;    col = ;     dir = ' ';  break;}
    //         case B13:   {row = ;    col = ;     dir = ' ';  break;}
    //         case B14:   {row = ;    col = ;     dir = ' ';  break;}
    //         case B15:   {row = ;    col = ;     dir = ' ';  break;}
    //         case B16:   {row = ;    col = ;     dir = ' ';  break;}

    //         case C1:    {row = ;    col = ;     dir = ' ';  break;}
    //         case C2:    {row = ;    col = ;     dir = ' ';  break;}
    //         case C3:    {row = 4;   col = 30;   dir = '<';  break;}
    //         case C4:    {row = 4;   col = 30;   dir = '>';  break;}
    //         case C5:    {row = ;    col = ;     dir = ' ';  break;}
    //         case C6:    {row = ;    col = ;     dir = ' ';  break;}
    //         case C7:    {row = ;    col = ;     dir = '<';  break;}
    //         case C8:    {row = ;    col = ;     dir = '>';  break;}
    //         case C9:    {row = ;    col = ;     dir = ' ';  break;}
    //         case C10:   {row = ;    col = ;     dir = ' ';  break;}
    //         case C11:   {row = ;    col = ;     dir = ' ';  break;}
    //         case C12:   {row = ;    col = ;     dir = ' ';  break;}
    //         case C13:   {row = 1;    col = 17;     dir = ' ';  break;}
    //         case C14:   {row = 1;    col = 17;     dir = ' ';  break;}
    //         case C15:   {row = ;    col = ;     dir = ' ';  break;}
    //         case C16:   {row = ;    col = ;     dir = ' ';  break;}

    //         case D1:    {row = ;    col = ;     dir = ' ';  break;}
    //         case D2:    {row = ;    col = ;     dir = ' ';  break;}
    //         case D3:    {row = ;    col = ;     dir = ' ';  break;}
    //         case D4:    {row = ;    col = ;     dir = ' ';  break;}
    //         case D5:    {row = ;    col = ;     dir = ' ';  break;}
    //         case D6:    {row = ;    col = ;     dir = ' ';  break;}
    //         case D7:    {row = ;    col = ;     dir = ' ';  break;}
    //         case D8:    {row = ;    col = ;     dir = ' ';  break;}
    //         case D9:    {row = ;    col = ;     dir = ' ';  break;}
    //         case D10:   {row = ;    col = ;     dir = ' ';  break;}
    //         case D11:   {row = ;    col = ;     dir = ' ';  break;}
    //         case D12:   {row = ;    col = ;     dir = ' ';  break;}
    //         case D13:   {row = ;    col = ;     dir = ' ';  break;}
    //         case D14:   {row = ;    col = ;     dir = ' ';  break;}
    //         case D15:   {row = ;    col = ;     dir = ' ';  break;}
    //         case D16:   {row = ;    col = ;     dir = ' ';  break;}

    //         case E1:    {row = ;    col = ;     dir = ' ';  break;}
    //         case E2:    {row = ;    col = ;     dir = ' ';  break;}
    //         case E3:    {row = ;    col = ;     dir = ' ';  break;}
    //         case E4:    {row = ;    col = ;     dir = ' ';  break;}
    //         case E5:    {row = ;    col = ;     dir = ' ';  break;}
    //         case E6:    {row = ;    col = ;     dir = ' ';  break;}
    //         case E7:    {row = ;    col = ;     dir = ' ';  break;}
    //         case E8:    {row = ;    col = ;     dir = ' ';  break;}
    //         case E9:    {row = ;    col = ;     dir = ' ';  break;}
    //         case E10:   {row = ;    col = ;     dir = ' ';  break;}
    //         case E11:   {row = ;    col = ;     dir = ' ';  break;}
    //         case E12:   {row = ;    col = ;     dir = ' ';  break;}
    //         case E13:   {row = ;    col = ;     dir = ' ';  break;}
    //         case E14:   {row = ;    col = ;     dir = ' ';  break;}
    //         case E15:   {row = ;    col = ;     dir = ' ';  break;}
    //         case E16:   {row = ;    col = ;     dir = ' ';  break;}

    //         default: assert(0);
    //     }
    // }
// }

static void sensorFormat(String *s, const SensorData *sensorReading) {
    if(sensorReading->offset == 0) {
        return;
    }
    // e.g. formats the SensorData to "A10"
    char alpha = sensorReading->group;
    char bit = sensorReading->offset;
    // Mmm alphabit soup
    sputstr(s, "      ");
    sputc(s, 'A' + alpha);
    sputc(s, '.');
    sputuint(s, bit, 10);
    sputstr(s, "      \r\n");
}

static void updateSensoryDisplay() {
    String s;
    sinit(&s);
    sputstr(&s, VT_CURSOR_SAVE);
    vt_pos(&s, VT_SENSOR_ROW + 1, VT_SENSOR_COL);

    for(int i = recently_read ; ; ) {
        sensorFormat(&s, &recent_sensors[i]);
        i = (i + 1) % NUM_RECENT_SENSORS;
        if(i == recently_read) {
            break;
        }
    }

    sputstr(&s, VT_RESET);
    sputstr(&s, VT_CURSOR_RESTORE);
    PutString(COM2, &s);
}


static inline void handleChar(char c, int reply_index) {
    sensor_states[last_byte] = c;

    char offset = ((reply_index % 2 == 0) ? 0 : 8);
    char i, index;
    for (i = 0, index = 8; i < 8; i++, index--) {
        if ((1 << i) & c) {
            int group_number = last_byte / 2;
            int group_offset = index + offset;
            setSensorData(&recent_sensors[recently_read], group_number, group_offset);
            updateSensoryDisplay();
            recently_read = (recently_read + 1) % NUM_RECENT_SENSORS;

            // check if reading was what we should halt on
            if(halt_reading.group == group_number && halt_reading.offset == group_offset) {
                trainSetSpeed(halt_train_number, 0);
            }
        }
    }

    last_byte = (last_byte + 1) % (2 * NUM_SENSORS);
}

static void sensorCourier()
{

}

static void sensorTask() {
    initDrawSensorArea();
    drawTrackLayoutGraph(A);
    Putc(COM1, SENSOR_RESET);

    while(1) {
        Putc(COM1, SENSOR_QUERY);
        for(int i = 0; i < (2 * NUM_SENSORS); i++) {
            char c = Getc(COM1);
            if(c != 0) {
                last_byte = i;
                handleChar(c, i);
            }
        }
    }

}

void initSensor() {
    debug("initSensor");

    for(int i = 0; i < NUM_RECENT_SENSORS; i++) {
        recent_sensors[i].group = recent_sensors[i].offset = 0;
    }
    for(int i = 0; i < 2 * NUM_SENSORS; i++) {
        sensor_states[i] = 0;
    }
    last_byte = 0;
    recently_read = 0;
    halt_train_number = 0;
    halt_reading.group = halt_reading.offset = 0;

    assert(STR_MAX_LEN > strlen(trackA));
    assert(STR_MAX_LEN > strlen(trackB));
    Create(PRIORITY_SENSOR_TASK, sensorTask);
}

void sensorHalt(int train_number, char sensor_group, int sensor_number) {
    // gets called by the parser
    assert(0 < train_number && train_number < 80);
    assert('a' <= sensor_group && sensor_group <= 'e');
    assert(1 <= sensor_number && sensor_number <= 16);

    int group = sensor_group - 'a';
    halt_train_number = train_number;
    setSensorData(&halt_reading, group, sensor_number);
}


void drawTrackLayoutGraph(Track which_track) {
    String s;
    sinit(&s);
    sputstr(&s, VT_CURSOR_SAVE);
    vt_pos(&s, VT_TRACK_GRAPH_ROW, VT_TRACK_GRAPH_COL);
    sputstr(&s, VT_RESET);
    sputstr(&s, which_track == A ? trackA : trackB);
    sputstr(&s, VT_RESET);
    sputstr(&s, VT_CURSOR_RESTORE);
    PutString(COM2, &s);
}
